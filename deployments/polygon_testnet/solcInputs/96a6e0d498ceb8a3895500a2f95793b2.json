{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/exchange-wrapper/ExchangeWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ExchangeWrapperCore.sol\";\n\ncontract ExchangeWrapper is ExchangeWrapperCore {\n    function __ExchangeWrapper_init(\n        address _exchangeV2,\n        address _rarible,\n        address _wyvern,\n        address _seaport,\n        address _x2y2,\n        address _looksrare,\n        address _sudoswap,\n        address _blur\n    ) external initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ExchangeWrapper_init_unchained(_exchangeV2, _rarible, _wyvern, _seaport, _x2y2, _looksrare, _sudoswap, _blur);\n    }\n}\n"
    },
    "src/exchange-wrapper/ExchangeWrapperCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../librairies/LibTransfer.sol\";\nimport \"../librairies/BpLibrary.sol\";\nimport \"../librairies/LibPart.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IWyvernExchange.sol\";\nimport \"./interfaces/IExchangeV2.sol\";\nimport \"./interfaces/ISeaPort.sol\";\nimport \"./interfaces/Ix2y2.sol\";\nimport \"./interfaces/ILooksRare.sol\";\nimport \"./interfaces/IBlurExchange.sol\";\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/ISwapRouterV3.sol\";\nimport \"./interfaces/ISwapRouterV2.sol\";\nimport \"../interfaces/INftTransferProxy.sol\";\nimport \"../interfaces/IERC20TransferProxy.sol\";\n\nabstract contract ExchangeWrapperCore is\n    Initializable,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ERC721Holder,\n    ERC1155Holder\n{\n    using LibTransfer for address;\n    using BpLibrary for uint;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public exchangeV2;\n    address public rarible;\n    address public wyvern;\n    address public seaport;\n    address public x2y2;\n    address public looksrare;\n    address public sudoswap;\n    address public blur;\n    ISwapRouterV2 public uniswapRouterV2;\n    ISwapRouterV3 public uniswapRouterV3;\n    address public wrappedToken;\n    address public erc20TransferProxy;\n\n    event Execution(bool result, address indexed sender);\n\n    enum Markets {\n        Rarible,\n        Wyvern,\n        SeaPort,\n        X2Y2,\n        LooksRare,\n        SudoSwap,\n        ExchangeV2,\n        Blur\n    }\n\n    enum AdditionalDataTypes {\n        NoAdditionalData,\n        RoyaltiesAdditionalData\n    }\n\n    /**\n        @notice struct for the purchase data\n        @param marketId - market key from Markets enum (what market to use)\n        @param amount - eth price (amount of eth that needs to be send to the marketplace)\n        @param fees - 2 fees (in base points) that are going to be taken on top of order amount encoded in 1 uint256\n                        bytes (27,28) used for dataType\n                        bytes (29,30) used for the first value (goes to feeRecipientFirst)\n                        bytes (31,32) are used for the second value (goes to feeRecipientSecond)\n        @param data - data for market call\n     */\n    struct PurchaseDetails {\n        Markets marketId;\n        uint256 amount;\n        uint fees;\n        bytes data;\n    }\n\n    /**\n        @notice struct for the data with additional Ddta\n        @param data - data for market call\n        @param additionalRoyalties - array additional Royalties (in base points plus address Royalty recipient)\n     */\n    struct AdditionalData {\n        bytes data;\n        uint[] additionalRoyalties;\n    }\n\n    /**\n        @notice struct for the swap in v3 data\n        @param path - tokenIn\n        @param amountOut - amountOut\n        @param amountInMaximum - amountInMaximum\n        @param unwrap - unwrap\n     */\n    struct SwapDetailsIn {\n        bytes path;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        bool unwrap;\n    }\n\n    /**\n        @notice struct for the swap out v3 data\n        @param path - path\n        @param amountIn - amountIn\n        @param amountOutMinimum - amountOutMinimum\n        @param unwrap - unwrap\n     */\n    struct SwapDetailsOut {\n        bytes path;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        bool unwrap;\n    }\n\n    /**\n        @notice struct for the swap in v2 data\n        @param path - tokenIn\n        @param amountOut - amountOut\n        @param amountInMaximum - amountInMaximum\n        @param binSteps - binSteps\n        @param unwrap - unwrap\n     */\n    struct SwapV2DetailsIn {\n        address[] path;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint256[] binSteps;\n        bool unwrap;\n    }\n\n    /**\n        @notice struct for the swap out v2 data\n        @param path - tokenIn\n        @param amountIn - amountIn\n        @param amountOutMinimum - amountOutMinimum\n        @param binSteps - binSteps\n        @param unwrap - unwrap\n     */\n    struct SwapV2DetailsOut {\n        address[] path;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint256[] binSteps;\n        bool unwrap;\n    }\n\n    function __ExchangeWrapper_init_unchained(\n        address _exchangeV2,\n        address _rarible,\n        address _wyvern,\n        address _seaport,\n        address _x2y2,\n        address _looksrare,\n        address _sudoswap,\n        address _blur\n    ) internal {\n        exchangeV2 = _exchangeV2;\n        rarible = _rarible;\n        wyvern = _wyvern;\n        seaport = _seaport;\n        x2y2 = _x2y2;\n        looksrare = _looksrare;\n        sudoswap = _sudoswap;\n        blur = _blur;\n    }\n\n    /// @notice Pause the contract\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpause the contract\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    /// @notice Set uniswap v2 router\n    function setUniswapV2(ISwapRouterV2 _uniswapRouterV2) external onlyOwner {\n        uniswapRouterV2 = _uniswapRouterV2;\n    }\n\n    /// @notice Set uniswap v3 router\n    function setUniswapV3(ISwapRouterV3 _uniswapRouterV3) external onlyOwner {\n        uniswapRouterV3 = _uniswapRouterV3;\n    }\n\n    /// @notice Set wrapped token\n    function setWrapped(address _wrappedToken) external onlyOwner {\n        wrappedToken = _wrappedToken;\n    }\n\n    /// @notice Set erc20 transfer proxy\n    function setTransferProxy(address _erc20TransferProxy) external onlyOwner {\n        erc20TransferProxy = _erc20TransferProxy;\n    }\n\n    /// temp for upgrade - to remove once initialized\n    function setRarible(address _rarible) external onlyOwner {\n        rarible = _rarible;\n    }\n\n    function setBlur(address _blur) external onlyOwner {\n        blur = _blur;\n    }\n\n    /// temp for upgrade - to remove once initialized\n\n    /**\n        @notice executes a single purchase\n        @param purchaseDetails - details about the purchase (more info in PurchaseDetails struct)\n        @param feeRecipientFirst - address of the first fee recipient\n        @param feeRecipientSecond - address of the second fee recipient\n     */\n    function singlePurchase(\n        PurchaseDetails memory purchaseDetails,\n        address feeRecipientFirst,\n        address feeRecipientSecond\n    ) public payable whenNotPaused {\n        (bool success, uint feeAmountFirst, uint feeAmountSecond) = purchase(purchaseDetails, false);\n        emit Execution(success, _msgSender());\n\n        transferFee(feeAmountFirst, feeRecipientFirst);\n        transferFee(feeAmountSecond, feeRecipientSecond);\n\n        transferChange();\n    }\n\n    /**\n        @notice executes an array of purchases - with swap v2 - tokens for tokens or tokens for eth/weth\n        @param purchaseDetails - array of details about the purchases (more info in PurchaseDetails struct)\n        @param feeRecipientFirst - address of the first fee recipient\n        @param feeRecipientSecond - address of the second fee recipient\n        @param allowFail - true if fails while executing orders are allowed, false if fail of a single order means fail of the whole batch\n        @param swapDetails - swapDetails v2\n     */\n\n    function bulkPurchaseWithV2Swap(\n        PurchaseDetails[] memory purchaseDetails,\n        address feeRecipientFirst,\n        address feeRecipientSecond,\n        bool allowFail,\n        SwapV2DetailsIn memory swapDetails\n    ) public payable whenNotPaused {\n        address tokenOut = swapDetails.path[swapDetails.path.length - 1];\n        // tokens for eth or weth\n        if (tokenOut == wrappedToken) {\n            bool isSwapExecuted = swapV2TokensForExactETHOrWETH(swapDetails, true);\n            require(isSwapExecuted, \"swap not successful\");\n        }\n        // tokens for tokens\n        else {\n            bool isSwapExecuted = swapV2TokensForExactTokens(swapDetails, true);\n            require(isSwapExecuted, \"swap not successful\");\n        }\n\n        bulkPurchase(purchaseDetails, feeRecipientFirst, feeRecipientSecond, allowFail);\n    }\n\n    /**\n        @notice executes an array of purchases - with swap v3\n        @param purchaseDetails - array of details about the purchases (more info in PurchaseDetails struct)\n        @param feeRecipientFirst - address of the first fee recipient\n        @param feeRecipientSecond - address of the second fee recipient\n        @param allowFail - true if fails while executing orders are allowed, false if fail of a single order means fail of the whole batch\n        @param swapDetails - swapDetails v3\n     */\n\n    function bulkPurchaseWithSwap(\n        PurchaseDetails[] memory purchaseDetails,\n        address feeRecipientFirst,\n        address feeRecipientSecond,\n        bool allowFail,\n        SwapDetailsIn memory swapDetails\n    ) public payable whenNotPaused {\n        bool isSwapExecuted = swapTokensForExactTokens(swapDetails, true);\n        require(isSwapExecuted, \"swap not successful\");\n        bulkPurchase(purchaseDetails, feeRecipientFirst, feeRecipientSecond, allowFail);\n    }\n\n    /**\n        @notice executes an array of purchases\n        @param purchaseDetails - array of details about the purchases (more info in PurchaseDetails struct)\n        @param feeRecipientFirst - address of the first fee recipient\n        @param feeRecipientSecond - address of the second fee recipient\n        @param allowFail - true if fails while executing orders are allowed, false if fail of a single order means fail of the whole batch\n     */\n\n    function bulkPurchase(\n        PurchaseDetails[] memory purchaseDetails,\n        address feeRecipientFirst,\n        address feeRecipientSecond,\n        bool allowFail\n    ) public payable whenNotPaused {\n        uint sumFirstFees = 0;\n        uint sumSecondFees = 0;\n        bool result = false;\n\n        uint length = purchaseDetails.length;\n        for (uint i; i < length; ++i) {\n            (bool success, uint firstFeeAmount, uint secondFeeAmount) = purchase(purchaseDetails[i], allowFail);\n\n            result = result || success;\n            emit Execution(success, _msgSender());\n\n            sumFirstFees = sumFirstFees + (firstFeeAmount);\n            sumSecondFees = sumSecondFees + (secondFeeAmount);\n        }\n\n        require(result, \"no successful executions\");\n\n        transferFee(sumFirstFees, feeRecipientFirst);\n        transferFee(sumSecondFees, feeRecipientSecond);\n\n        transferChange();\n    }\n\n    /**\n        @notice executes one purchase\n        @param purchaseDetails - details about the purchase\n        @param allowFail - true if errors are handled, false if revert on errors\n        @return result false if execution failed, true if succeded\n        @return firstFeeAmount amount of the first fee of the purchase, 0 if failed\n        @return secondFeeAmount amount of the second fee of the purchase, 0 if failed\n     */\n    function purchase(PurchaseDetails memory purchaseDetails, bool allowFail) internal returns (bool, uint, uint) {\n        (bytes memory marketData, uint[] memory additionalRoyalties) = getDataAndAdditionalData(\n            purchaseDetails.data,\n            purchaseDetails.fees,\n            purchaseDetails.marketId\n        );\n        uint paymentAmount = purchaseDetails.amount;\n        if (purchaseDetails.marketId == Markets.SeaPort) {\n            (bool success, ) = address(seaport).call{value: paymentAmount}(marketData);\n            if (allowFail) {\n                if (!success) {\n                    return (false, 0, 0);\n                }\n            } else {\n                require(success, \"Purchase Seaport failed\");\n            }\n        } else if (purchaseDetails.marketId == Markets.Wyvern) {\n            (bool success, ) = address(wyvern).call{value: paymentAmount}(marketData);\n            if (allowFail) {\n                if (!success) {\n                    return (false, 0, 0);\n                }\n            } else {\n                require(success, \"Purchase Wyvern failed\");\n            }\n        } else if (purchaseDetails.marketId == Markets.ExchangeV2) {\n            (bool success, ) = address(exchangeV2).call{value: paymentAmount}(marketData);\n            if (allowFail) {\n                if (!success) {\n                    return (false, 0, 0);\n                }\n            } else {\n                require(success, \"Purchase GhostMarket failed\");\n            }\n        } else if (purchaseDetails.marketId == Markets.Rarible) {\n            (bool success, ) = address(rarible).call{value: paymentAmount}(marketData);\n            if (allowFail) {\n                if (!success) {\n                    return (false, 0, 0);\n                }\n            } else {\n                require(success, \"Purchase Rarible failed\");\n            }\n        } else if (purchaseDetails.marketId == Markets.X2Y2) {\n            Ix2y2.RunInput memory input = abi.decode(marketData, (Ix2y2.RunInput));\n\n            if (allowFail) {\n                try Ix2y2(x2y2).run{value: paymentAmount}(input) {} catch {\n                    return (false, 0, 0);\n                }\n            } else {\n                Ix2y2(x2y2).run{value: paymentAmount}(input);\n            }\n\n            // for every element in input.details[] getting\n            // order = input.details[i].orderIdx\n            // and from that order getting item = input.details[i].itemId\n            uint length = input.details.length;\n            for (uint i; i < length; ++i) {\n                uint orderId = input.details[i].orderIdx;\n                uint itemId = input.details[i].itemIdx;\n                bytes memory data = input.orders[orderId].items[itemId].data;\n                {\n                    if (input.orders[orderId].dataMask.length > 0 && input.details[i].dataReplacement.length > 0) {\n                        _arrayReplace(data, input.details[i].dataReplacement, input.orders[orderId].dataMask);\n                    }\n                }\n\n                // 1 = erc-721\n                if (input.orders[orderId].delegateType == 1) {\n                    Ix2y2.Pair721[] memory pairs = abi.decode(data, (Ix2y2.Pair721[]));\n\n                    for (uint256 j = 0; j < pairs.length; j++) {\n                        Ix2y2.Pair721 memory p = pairs[j];\n                        IERC721Upgradeable(address(p.token)).safeTransferFrom(address(this), _msgSender(), p.tokenId);\n                    }\n                } else if (input.orders[orderId].delegateType == 2) {\n                    // 2 = erc-1155\n                    Ix2y2.Pair1155[] memory pairs = abi.decode(data, (Ix2y2.Pair1155[]));\n\n                    for (uint256 j = 0; j < pairs.length; j++) {\n                        Ix2y2.Pair1155 memory p = pairs[j];\n                        IERC1155Upgradeable(address(p.token)).safeTransferFrom(\n                            address(this),\n                            _msgSender(),\n                            p.tokenId,\n                            p.amount,\n                            \"\"\n                        );\n                    }\n                } else {\n                    revert(\"unknown delegateType x2y2\");\n                }\n            }\n        } else if (purchaseDetails.marketId == Markets.LooksRare) {\n            (LibLooksRare.TakerOrder memory takerOrder, LibLooksRare.MakerOrder memory makerOrder, bytes4 typeNft) = abi\n                .decode(marketData, (LibLooksRare.TakerOrder, LibLooksRare.MakerOrder, bytes4));\n            if (allowFail) {\n                try\n                    ILooksRare(looksrare).matchAskWithTakerBidUsingETHAndWETH{value: paymentAmount}(\n                        takerOrder,\n                        makerOrder\n                    )\n                {} catch {\n                    return (false, 0, 0);\n                }\n            } else {\n                ILooksRare(looksrare).matchAskWithTakerBidUsingETHAndWETH{value: paymentAmount}(takerOrder, makerOrder);\n            }\n            if (typeNft == LibAsset.ERC721_ASSET_CLASS) {\n                IERC721Upgradeable(makerOrder.collection).safeTransferFrom(\n                    address(this),\n                    _msgSender(),\n                    makerOrder.tokenId\n                );\n            } else if (typeNft == LibAsset.ERC1155_ASSET_CLASS) {\n                IERC1155Upgradeable(makerOrder.collection).safeTransferFrom(\n                    address(this),\n                    _msgSender(),\n                    makerOrder.tokenId,\n                    makerOrder.amount,\n                    \"\"\n                );\n            } else {\n                revert(\"Unknown token type\");\n            }\n        } else if (purchaseDetails.marketId == Markets.SudoSwap) {\n            (bool success, ) = address(sudoswap).call{value: paymentAmount}(marketData);\n            if (allowFail) {\n                if (!success) {\n                    return (false, 0, 0);\n                }\n            } else {\n                require(success, \"Purchase SudoSwap failed\");\n            }\n        } else if (purchaseDetails.marketId == Markets.Blur) {\n            (bool success, ) = address(blur).call{value: paymentAmount}(marketData);\n            if (allowFail) {\n                if (!success) {\n                    return (false, 0, 0);\n                }\n            } else {\n                require(success, \"Purchase blurio failed\");\n            }\n        } else {\n            revert(\"Unknown purchase details\");\n        }\n\n        //transferring royalties\n        transferAdditionalRoyalties(additionalRoyalties, purchaseDetails.amount);\n\n        (uint firstFeeAmount, uint secondFeeAmount) = getFees(purchaseDetails.fees, purchaseDetails.amount);\n        return (true, firstFeeAmount, secondFeeAmount);\n    }\n\n    /**\n        @notice transfers fee to feeRecipient\n        @param feeAmount - amount to be transfered\n        @param feeRecipient - address of the recipient\n     */\n    function transferFee(uint feeAmount, address feeRecipient) internal {\n        if (feeAmount > 0 && feeRecipient != address(0)) {\n            LibTransfer.transferEth(feeRecipient, feeAmount);\n        }\n    }\n\n    /**\n        @notice transfers change back to sender\n     */\n    function transferChange() internal {\n        uint ethAmount = address(this).balance;\n        if (ethAmount > 0) {\n            address(msg.sender).transferEth(ethAmount);\n        }\n    }\n\n    /**\n        @notice parses fees in base points from one uint and calculates real amount of fees\n        @param fees two fees encoded in one uint, 29 and 30 bytes are used for the first fee, 31 and 32 bytes for second fee\n        @param amount price of the order\n        @return firstFeeAmount real amount for the first fee\n        @return secondFeeAmount real amount for the second fee\n     */\n    function getFees(uint fees, uint amount) internal pure returns (uint, uint) {\n        uint firstFee = uint(uint16(fees >> 16));\n        uint secondFee = uint(uint16(fees));\n        return (amount.bp(firstFee), amount.bp(secondFee));\n    }\n\n    /**\n        @notice parses _data to data for market call and additionalData\n        @param feesAndDataType 27 and 28 bytes for dataType\n        @return marketData data for market call\n        @return additionalRoyalties array uint256, (base point + address)\n     */\n    function getDataAndAdditionalData(\n        bytes memory _data,\n        uint feesAndDataType,\n        Markets marketId\n    ) internal pure returns (bytes memory, uint[] memory) {\n        AdditionalDataTypes dataType = AdditionalDataTypes(uint16(feesAndDataType >> 32));\n        uint[] memory additionalRoyalties;\n\n        //return no royalties if wrong data type\n        if (dataType == AdditionalDataTypes.NoAdditionalData) {\n            return (_data, additionalRoyalties);\n        }\n\n        if (dataType == AdditionalDataTypes.RoyaltiesAdditionalData) {\n            AdditionalData memory additionalData = abi.decode(_data, (AdditionalData));\n\n            //return no royalties if market doesn't support royalties\n            if (supportsRoyalties(marketId)) {\n                return (additionalData.data, additionalData.additionalRoyalties);\n            } else {\n                return (additionalData.data, additionalRoyalties);\n            }\n        }\n\n        revert(\"unknown additionalDataType\");\n    }\n\n    /**\n        @notice transfer additional royalties\n        @param _additionalRoyalties array uint256 (base point + royalty recipient address)\n     */\n    function transferAdditionalRoyalties(uint[] memory _additionalRoyalties, uint amount) internal {\n        uint length = _additionalRoyalties.length;\n        for (uint i; i < length; ++i) {\n            if (_additionalRoyalties[i] > 0) {\n                address payable account = payable(address(uint160(_additionalRoyalties[i])));\n                uint basePoint = uint(_additionalRoyalties[i] >> 160);\n                uint value = amount.bp(basePoint);\n                transferFee(value, account);\n            }\n        }\n    }\n\n    // modifies `src`\n    function _arrayReplace(bytes memory src, bytes memory replacement, bytes memory mask) internal view virtual {\n        require(src.length == replacement.length);\n        require(src.length == mask.length);\n\n        uint256 length = src.length;\n        for (uint256 i; i < length; ++i) {\n            if (mask[i] != 0) {\n                src[i] = replacement[i];\n            }\n        }\n    }\n\n    /**\n        @notice returns true if this contract supports additional royalties for the marketpale\n        now royalties support only for marketId = sudoswap\n    */\n    function supportsRoyalties(Markets marketId) internal pure returns (bool) {\n        if (marketId == Markets.SudoSwap || marketId == Markets.LooksRare) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice swaps tokens for exact tokens - uniswap v2\n     * @param swapDetails swapDetails required\n     * @param combined combined swap + buy - if true funds are not sent back to sender buy kept for trade\n     */\n    function swapV2TokensForExactTokens(SwapV2DetailsIn memory swapDetails, bool combined) public returns (bool) {\n        // extract tokenIn from path\n        address tokenIn = swapDetails.path[0];\n\n        // Move tokenIn to contract\n        IERC20TransferProxy(erc20TransferProxy).erc20safeTransferFrom(\n            IERC20Upgradeable(tokenIn),\n            _msgSender(),\n            address(this),\n            swapDetails.amountInMaximum\n        );\n\n        // Approve tokenIn on uniswap\n        uint256 allowance = IERC20Upgradeable(tokenIn).allowance(address(uniswapRouterV2), address(this));\n        if (allowance < swapDetails.amountInMaximum) {\n            IERC20Upgradeable(tokenIn).approve(address(uniswapRouterV2), type(uint256).max);\n        }\n\n        // Swap\n        uint256 chainId = block.chainid;\n        bool isAvalanche = chainId == 43114 || chainId == 43113;\n        uint256 amountIn;\n\n        if (isAvalanche) {\n            try\n                uniswapRouterV2.swapTokensForExactTokens(\n                    swapDetails.amountOut, // amountOut\n                    swapDetails.amountInMaximum, // amountInMaximum\n                    swapDetails.binSteps, // binSteps\n                    swapDetails.path, // path\n                    address(this), // recipient\n                    block.timestamp // deadline\n                )\n            returns (uint[] memory amounts) {\n                amountIn = amounts[0];\n            } catch {\n                return false;\n            }\n        } else {\n            try\n                uniswapRouterV2.swapTokensForExactTokens(\n                    swapDetails.amountOut, // amountOut\n                    swapDetails.amountInMaximum, // amountInMaximum\n                    swapDetails.path, // path\n                    address(this), // recipient\n                    block.timestamp // deadline\n                )\n            returns (uint[] memory amounts) {\n                amountIn = amounts[0];\n            } catch {\n                return false;\n            }\n        }\n\n        // Refund tokenIn left if any\n        if (amountIn < swapDetails.amountInMaximum) {\n            IERC20Upgradeable(tokenIn).transfer(_msgSender(), swapDetails.amountInMaximum - amountIn);\n        }\n\n        if (!combined) {\n            address tokenOut = swapDetails.path[swapDetails.path.length - 1];\n            IERC20Upgradeable(tokenOut).transfer(_msgSender(), swapDetails.amountOut);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice swaps exact tokens for tokens - uniswap v2\n     * @param swapDetails swapDetails required\n     */\n    function swapV2ExactTokensForTokens(SwapV2DetailsOut memory swapDetails) public returns (bool) {\n        // extract tokenIn / tokenOut from path\n        address tokenIn = swapDetails.path[0];\n        address tokenOut = swapDetails.path[swapDetails.path.length - 1];\n\n        // Move tokenIn to contract\n        IERC20TransferProxy(erc20TransferProxy).erc20safeTransferFrom(\n            IERC20Upgradeable(tokenIn),\n            _msgSender(),\n            address(this),\n            swapDetails.amountIn\n        );\n\n        // Approve tokenIn on uniswap\n        uint256 allowance = IERC20Upgradeable(tokenIn).allowance(address(uniswapRouterV2), address(this));\n        if (allowance < swapDetails.amountIn) {\n            IERC20Upgradeable(tokenIn).approve(address(uniswapRouterV2), type(uint256).max);\n        }\n\n        // Swap\n        uint256 chainId = block.chainid;\n        bool isAvalanche = chainId == 43114 || chainId == 43113;\n        uint256 amountOut;\n\n        if (isAvalanche) {\n            try\n                uniswapRouterV2.swapTokensForExactTokens(\n                    swapDetails.amountIn, // amountIn\n                    swapDetails.amountOutMinimum, // amountOutMinimum\n                    swapDetails.binSteps, // binSteps\n                    swapDetails.path, // path\n                    address(this), // recipient\n                    block.timestamp // deadline\n                )\n            returns (uint[] memory amounts) {\n                amountOut = amounts[0];\n            } catch {\n                return false;\n            }\n        } else {\n            try\n                uniswapRouterV2.swapTokensForExactTokens(\n                    swapDetails.amountIn, // amountIn\n                    swapDetails.amountOutMinimum, // amountOutMinimum\n                    swapDetails.path, // path\n                    address(this), // recipient\n                    block.timestamp // deadline\n                )\n            returns (uint[] memory amounts) {\n                amountOut = amounts[0];\n            } catch {\n                return false;\n            }\n        }\n\n        // send token out back\n        IERC20Upgradeable(tokenOut).transfer(_msgSender(), amountOut);\n\n        return true;\n    }\n\n    /**\n     * @notice swaps tokens for exact ETH or WETH - uniswap v2\n     * @param swapDetails swapDetails required\n     * @param combined combined swap + buy - if true funds are not sent back to sender buy kept for trade\n     */\n    function swapV2TokensForExactETHOrWETH(SwapV2DetailsIn memory swapDetails, bool combined) public returns (bool) {\n        // extract tokenIn from path\n        address tokenIn = swapDetails.path[0];\n\n        // Move tokenIn to contract\n        IERC20TransferProxy(erc20TransferProxy).erc20safeTransferFrom(\n            IERC20Upgradeable(tokenIn),\n            _msgSender(),\n            address(this),\n            swapDetails.amountInMaximum\n        );\n\n        // if source = wrapped and destination = native, unwrap and return\n        if (tokenIn == wrappedToken && swapDetails.unwrap) {\n            IWETH(wrappedToken).withdraw(swapDetails.amountInMaximum);\n            if (!combined) {\n                address(_msgSender()).transferEth(swapDetails.amountInMaximum);\n            }\n            return true;\n        }\n\n        // Approve tokenIn on uniswap\n        uint256 allowance = IERC20Upgradeable(tokenIn).allowance(address(uniswapRouterV2), address(this));\n        if (allowance < swapDetails.amountInMaximum) {\n            IERC20Upgradeable(tokenIn).approve(address(uniswapRouterV2), type(uint256).max);\n        }\n\n        // Swap\n        uint256 chainId = block.chainid;\n        bool isAvalanche = chainId == 43114 || chainId == 43113;\n        uint256 amountIn;\n        if (isAvalanche) {\n            try\n                uniswapRouterV2.swapTokensForExactAVAX(\n                    swapDetails.amountOut, // amountOut\n                    swapDetails.amountInMaximum, // amountInMaximum\n                    swapDetails.binSteps, // binSteps\n                    swapDetails.path, // path\n                    address(this), // recipient\n                    block.timestamp // deadline\n                )\n            returns (uint[] memory amounts) {\n                amountIn = amounts[0];\n            } catch {\n                return false;\n            }\n        } else {\n            try\n                uniswapRouterV2.swapTokensForExactETH(\n                    swapDetails.amountOut, // amountOut\n                    swapDetails.amountInMaximum, // amountInMaximum\n                    swapDetails.path, // path\n                    address(this), // recipient\n                    block.timestamp // deadline\n                )\n            returns (uint[] memory amounts) {\n                amountIn = amounts[0];\n            } catch {\n                return false;\n            }\n        }\n\n        // Refund tokenIn left if any\n        if (amountIn < swapDetails.amountInMaximum) {\n            IERC20Upgradeable(tokenIn).transfer(_msgSender(), swapDetails.amountInMaximum - amountIn);\n        }\n\n        // Wrap if required\n        if (swapDetails.unwrap) {\n            IWETH(wrappedToken).deposit{value: swapDetails.amountOut}();\n        }\n\n        if (!combined) {\n            if (swapDetails.unwrap) {\n                address tokenOut = swapDetails.path[swapDetails.path.length - 1];\n                IERC20Upgradeable(tokenOut).transfer(_msgSender(), swapDetails.amountOut);\n            } else {\n                address(_msgSender()).transferEth(swapDetails.amountOut);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice swaps exact ETH or WETH for tokens - uniswap v2\n     * @param swapDetails swapDetails required\n     */\n    function swapV2ExactETHOrWETHForTokens(SwapV2DetailsOut memory swapDetails) public payable returns (bool) {\n        // extract tokenIn / tokenOut from path\n        address tokenIn = swapDetails.path[0];\n        address tokenOut = swapDetails.path[swapDetails.path.length - 1];\n\n        // Move tokenIn to contract if ERC20\n        if (msg.value == 0) {\n            IERC20TransferProxy(erc20TransferProxy).erc20safeTransferFrom(\n                IERC20Upgradeable(tokenIn),\n                _msgSender(),\n                address(this),\n                swapDetails.amountIn\n            );\n\n            IWETH(wrappedToken).withdraw(swapDetails.amountIn);\n        }\n\n        // if source = native and destination = wrapped, wrap and return\n        if (msg.value > 0 && tokenOut == wrappedToken) {\n            IWETH(wrappedToken).deposit{value: msg.value}();\n            IERC20Upgradeable(tokenOut).transfer(_msgSender(), swapDetails.amountIn);\n            return true;\n        }\n\n        // Swap\n        uint256 chainId = block.chainid;\n        bool isAvalanche = chainId == 43114 || chainId == 43113;\n        uint256 amountOut;\n        if (isAvalanche) {\n            try\n                uniswapRouterV2.swapExactAVAXForTokens(\n                    swapDetails.amountOutMinimum, // amountOutMinimum\n                    swapDetails.binSteps, // binSteps\n                    swapDetails.path, // path\n                    address(this), // recipient\n                    block.timestamp // deadline\n                )\n            returns (uint[] memory amounts) {\n                amountOut = amounts[0];\n            } catch {\n                return false;\n            }\n        } else {\n            try\n                uniswapRouterV2.swapExactETHForTokens(\n                    swapDetails.amountOutMinimum, // amountOutMinimum\n                    swapDetails.path, // path\n                    address(this), // recipient\n                    block.timestamp // deadline\n                )\n            returns (uint[] memory amounts) {\n                amountOut = amounts[0];\n            } catch {\n                return false;\n            }\n        }\n\n        // send token out back\n        IERC20Upgradeable(tokenOut).transfer(_msgSender(), amountOut);\n\n        return true;\n    }\n\n    /**\n     * @notice swaps tokens for exact tokens - uniswap v3\n     * @param swapDetails swapDetails required\n     * @param combined combined swap + buy - if true funds are not sent back to sender buy kept for trade\n     */\n    function swapTokensForExactTokens(SwapDetailsIn memory swapDetails, bool combined) public payable returns (bool) {\n        // extract tokenIn / tokenOut from path\n        address tokenIn;\n        address tokenOut;\n        bytes memory _path = swapDetails.path;\n        uint _start = _path.length - 20;\n        assembly {\n            tokenIn := div(mload(add(add(_path, 0x20), _start)), 0x1000000000000000000000000)\n            tokenOut := div(mload(add(add(_path, 0x20), 0)), 0x1000000000000000000000000)\n        }\n\n        // Move tokenIn to contract if ERC20\n        if (msg.value == 0) {\n            IERC20TransferProxy(erc20TransferProxy).erc20safeTransferFrom(\n                IERC20Upgradeable(tokenIn),\n                _msgSender(),\n                address(this),\n                swapDetails.amountInMaximum\n            );\n        }\n\n        // if source = wrapped and destination = native, unwrap and return\n        if (tokenIn == wrappedToken && swapDetails.unwrap) {\n            IWETH(wrappedToken).withdraw(swapDetails.amountOut);\n            if (!combined) {\n                address(_msgSender()).transferEth(swapDetails.amountOut);\n            }\n            return true;\n        }\n\n        // if source = native and destination = wrapped, wrap and return\n        if (msg.value > 0 && tokenOut == wrappedToken) {\n            IWETH(wrappedToken).deposit{value: msg.value}();\n            if (!combined) {\n                IERC20Upgradeable(tokenOut).transfer(_msgSender(), swapDetails.amountOut);\n            }\n            return true;\n        }\n\n        // Approve tokenIn on uniswap\n        uint256 allowance = IERC20Upgradeable(tokenIn).allowance(address(uniswapRouterV3), address(this));\n        if (allowance < swapDetails.amountInMaximum) {\n            IERC20Upgradeable(tokenIn).approve(address(uniswapRouterV3), type(uint256).max);\n        }\n\n        // Set the order parameters\n        ISwapRouterV3.ExactOutputParams memory params = ISwapRouterV3.ExactOutputParams(\n            swapDetails.path, // path\n            address(this), // recipient\n            block.timestamp, // deadline\n            swapDetails.amountOut, // amountOut\n            swapDetails.amountInMaximum // amountInMaximum\n        );\n\n        // Swap\n        uint256 amountIn;\n        try uniswapRouterV3.exactOutput(params) returns (uint256 amount) {\n            amountIn = amount;\n        } catch {\n            return false;\n        }\n\n        // Refund ETH from swap if any\n        uniswapRouterV3.refundETH();\n\n        // Unwrap if required\n        if (swapDetails.unwrap) {\n            IWETH(wrappedToken).withdraw(swapDetails.amountOut);\n        }\n\n        // Refund tokenIn left if any\n        if (amountIn < swapDetails.amountInMaximum) {\n            IERC20Upgradeable(tokenIn).transfer(_msgSender(), swapDetails.amountInMaximum - amountIn);\n        }\n\n        if (!combined) {\n            if (swapDetails.unwrap) {\n                address(_msgSender()).transferEth(swapDetails.amountOut);\n            } else {\n                IERC20Upgradeable(tokenOut).transfer(_msgSender(), swapDetails.amountOut);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice swaps exact tokens for tokens - uniswap v3\n     * @param swapDetails swapDetails required\n     */\n    function swapExactTokensForTokens(SwapDetailsOut memory swapDetails) public payable returns (bool) {\n        // extract tokenIn / tokenOut from path\n        address tokenIn;\n        address tokenOut;\n        bytes memory _path = swapDetails.path;\n        uint _start = _path.length - 20;\n        assembly {\n            tokenIn := div(mload(add(add(_path, 0x20), _start)), 0x1000000000000000000000000)\n            tokenOut := div(mload(add(add(_path, 0x20), 0)), 0x1000000000000000000000000)\n        }\n\n        // Move tokenIn to contract if ERC20\n        if (msg.value == 0) {\n            IERC20TransferProxy(erc20TransferProxy).erc20safeTransferFrom(\n                IERC20Upgradeable(tokenIn),\n                _msgSender(),\n                address(this),\n                swapDetails.amountIn\n            );\n        }\n\n        // if source = wrapped and destination = native, unwrap and return\n        if (tokenIn == wrappedToken && swapDetails.unwrap) {\n            IWETH(wrappedToken).withdraw(swapDetails.amountIn);\n            address(_msgSender()).transferEth(swapDetails.amountIn);\n            return true;\n        }\n\n        // if source = native and destination = wrapped, wrap and return\n        if (msg.value > 0 && tokenOut == wrappedToken) {\n            IWETH(wrappedToken).deposit{value: msg.value}();\n            IERC20Upgradeable(tokenOut).transfer(_msgSender(), swapDetails.amountIn);\n            return true;\n        }\n\n        // Approve tokenIn on uniswap\n        uint256 allowance = IERC20Upgradeable(tokenIn).allowance(address(uniswapRouterV3), address(this));\n        if (allowance < swapDetails.amountIn) {\n            IERC20Upgradeable(tokenIn).approve(address(uniswapRouterV3), type(uint256).max);\n        }\n\n        // Set the order parameters\n        ISwapRouterV3.ExactInputParams memory params = ISwapRouterV3.ExactInputParams(\n            swapDetails.path, // path\n            address(this), // recipient\n            block.timestamp, // deadline\n            swapDetails.amountIn, // amountIn\n            swapDetails.amountOutMinimum // amountOutMinimum\n        );\n\n        // Swap\n        uint256 amountOut;\n        try uniswapRouterV3.exactInput(params) returns (uint256 amount) {\n            amountOut = amount;\n        } catch {\n            return false;\n        }\n\n        // Refund ETH from swap if any\n        uniswapRouterV3.refundETH();\n\n        // Unwrap if required\n        if (swapDetails.unwrap) {\n            IWETH(wrappedToken).withdraw(amountOut);\n        }\n\n        // send token out back\n        if (swapDetails.unwrap) {\n            address(_msgSender()).transferEth(amountOut);\n        } else {\n            IERC20Upgradeable(tokenOut).transfer(_msgSender(), amountOut);\n        }\n\n        return true;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "src/exchange-wrapper/interfaces/IBlurExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport {Input, Order} from \"../librairies/OrderStructs.sol\";\n\ninterface IBlurExchange {\n    function nonces(address) external view returns (uint256);\n\n    function cancelOrder(Order calldata order) external;\n\n    function cancelOrders(Order[] calldata orders) external;\n\n    function incrementNonce() external;\n\n    function execute(Input calldata sell, Input calldata buy) external payable;\n}\n"
    },
    "src/exchange-wrapper/interfaces/IExchangeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../librairies/LibOrder.sol\";\nimport \"../../librairies/LibDirectTransfer.sol\";\n\ninterface IExchangeV2 {\n    function matchOrders(\n        LibOrder.Order memory orderLeft,\n        bytes memory signatureLeft,\n        LibOrder.Order memory orderRight,\n        bytes memory signatureRight\n    ) external payable;\n\n    function directPurchase(LibDirectTransfer.Purchase calldata direct) external payable;\n}\n"
    },
    "src/exchange-wrapper/interfaces/ILooksRare.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../librairies/LibLooksRare.sol\";\n\ninterface ILooksRare {\n    function matchAskWithTakerBidUsingETHAndWETH(\n        LibLooksRare.TakerOrder calldata takerBid,\n        LibLooksRare.MakerOrder calldata makerAsk\n    ) external payable;\n}\n"
    },
    "src/exchange-wrapper/interfaces/ILSSVMRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ILSSVMRouter {\n    struct PairSwapSpecific {\n        address pair;\n        uint256[] nftIds;\n    }\n\n    /**\n        @notice Swaps ETH into specific NFTs using multiple pairs.\n        @param swapList The list of pairs to trade with and the IDs of the NFTs to buy from each.\n        @param ethRecipient The address that will receive the unspent ETH input\n        @param nftRecipient The address that will receive the NFT output\n        @param deadline The Unix timestamp (in seconds) at/after which the swap will revert\n        @return remainingValue The unspent ETH amount\n     */\n    function swapETHForSpecificNFTs(\n        PairSwapSpecific[] calldata swapList,\n        address payable ethRecipient,\n        address nftRecipient,\n        uint256 deadline\n    ) external payable returns (uint256 remainingValue);\n}\n"
    },
    "src/exchange-wrapper/interfaces/ISeaPort.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../librairies/LibSeaPort.sol\";\n\ninterface ISeaPort {\n    function fulfillAdvancedOrder(\n        LibSeaPort.AdvancedOrder calldata advancedOrder,\n        LibSeaPort.CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) external payable returns (bool fulfilled);\n\n    function fulfillAvailableAdvancedOrders(\n        LibSeaPort.AdvancedOrder[] memory advancedOrders,\n        LibSeaPort.CriteriaResolver[] calldata criteriaResolvers,\n        LibSeaPort.FulfillmentComponent[][] calldata offerFulfillments,\n        LibSeaPort.FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    ) external payable returns (bool[] memory availableOrders, LibSeaPort.Execution[] memory executions);\n\n    function fulfillBasicOrder(\n        LibSeaPort.BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n}\n"
    },
    "src/exchange-wrapper/interfaces/ISwapRouterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V2\ninterface ISwapRouterV2 {\n    // regular\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMinimum,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMaximum,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint amountOutMinimum,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint amountOut,\n        uint amountInMaximum,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMinimum,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    // avalanche\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMinimum,\n        uint[] calldata binSteps,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMaximum,\n        uint[] calldata binSteps,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactAVAXForTokens(\n        uint amountOutMinimum,\n        uint[] calldata binSteps,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactAVAX(\n        uint amountOut,\n        uint amountInMaximum,\n        uint[] calldata binSteps,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForAVAX(\n        uint amountIn,\n        uint amountOutMinimum,\n        uint[] calldata binSteps,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapAVAXForExactTokens(\n        uint amountOut,\n        uint[] calldata binSteps,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n}\n"
    },
    "src/exchange-wrapper/interfaces/ISwapRouterV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IUniswapV3SwapCallback.sol\";\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouterV3 is IUniswapV3SwapCallback {\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n\n    function refundETH() external payable;\n}\n"
    },
    "src/exchange-wrapper/interfaces/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n"
    },
    "src/exchange-wrapper/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "src/exchange-wrapper/interfaces/IWyvernExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IWyvernExchange {\n    function atomicMatch_(\n        address[14] memory addrs,\n        uint[18] memory uints,\n        uint8[8] memory feeMethodsSidesKindsHowToCalls,\n        bytes memory calldataBuy,\n        bytes memory calldataSell,\n        bytes memory replacementPatternBuy,\n        bytes memory replacementPatternSell,\n        bytes memory staticExtradataBuy,\n        bytes memory staticExtradataSell,\n        uint8[2] memory vs,\n        bytes32[5] memory rssMetadata\n    ) external payable;\n\n    enum Side {\n        Buy,\n        Sell\n    }\n\n    enum SaleKind {\n        FixedPrice,\n        DutchAuction\n    }\n\n    function calculateFinalPrice(\n        Side side,\n        SaleKind saleKind,\n        uint256 basePrice,\n        uint256 extra,\n        uint256 listingTime,\n        uint256 expirationTime\n    ) external view returns (uint256);\n}\n"
    },
    "src/exchange-wrapper/interfaces/Ix2y2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface Ix2y2 {\n    struct OrderItem {\n        uint256 price;\n        bytes data;\n    }\n\n    struct Pair721 {\n        address token;\n        uint256 tokenId;\n    }\n\n    struct Pair1155 {\n        address token;\n        uint256 tokenId;\n        uint256 amount;\n    }\n\n    struct Order {\n        uint256 salt;\n        address user;\n        uint256 network;\n        uint256 intent;\n        uint256 delegateType;\n        uint256 deadline;\n        address currency;\n        bytes dataMask;\n        OrderItem[] items;\n        // signature\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        uint8 signVersion;\n    }\n\n    struct Fee {\n        uint256 percentage;\n        address to;\n    }\n\n    struct SettleDetail {\n        Op op;\n        uint256 orderIdx;\n        uint256 itemIdx;\n        uint256 price;\n        bytes32 itemHash;\n        address executionDelegate;\n        bytes dataReplacement;\n        uint256 bidIncentivePct;\n        uint256 aucMinIncrementPct;\n        uint256 aucIncDurationSecs;\n        Fee[] fees;\n    }\n\n    struct SettleShared {\n        uint256 salt;\n        uint256 deadline;\n        uint256 amountToEth;\n        uint256 amountToWeth;\n        address user;\n        bool canFail;\n    }\n\n    struct RunInput {\n        Order[] orders;\n        SettleDetail[] details;\n        SettleShared shared;\n        // signature\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n    }\n\n    enum Op {\n        INVALID,\n        // off-chain\n        COMPLETE_SELL_OFFER,\n        COMPLETE_BUY_OFFER,\n        CANCEL_OFFER,\n        // auction\n        BID,\n        COMPLETE_AUCTION,\n        REFUND_AUCTION,\n        REFUND_AUCTION_STUCK_ITEM\n    }\n\n    function run(RunInput memory input) external payable;\n}\n"
    },
    "src/exchange-wrapper/librairies/LibBlur.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nlibrary LibBlur {\n    enum Side {\n        Buy,\n        Sell\n    }\n    enum SignatureVersion {\n        Single,\n        Bulk\n    }\n    enum AssetType {\n        ERC721,\n        ERC1155\n    }\n\n    struct Fee {\n        uint16 rate;\n        address payable recipient;\n    }\n\n    struct Order {\n        address trader;\n        Side side;\n        address matchingPolicy;\n        address collection;\n        uint256 tokenId;\n        uint256 amount;\n        address paymentToken;\n        uint256 price;\n        uint256 listingTime;\n        /* Order expiration timestamp - 0 for oracle cancellations. */\n        uint256 expirationTime;\n        Fee[] fees;\n        uint256 salt;\n        bytes extraParams;\n    }\n\n    struct Input {\n        Order order;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        bytes extraSignature;\n        SignatureVersion signatureVersion;\n        uint256 blockNumber;\n    }\n\n    struct Execution {\n        Input sell;\n        Input buy;\n    }\n}\n"
    },
    "src/exchange-wrapper/librairies/LibLooksRare.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nlibrary LibLooksRare {\n    struct MakerOrder {\n        bool isOrderAsk; // true --> ask / false --> bid\n        address signer; // signer of the maker order\n        address collection; // collection address\n        uint256 price; // price (used as )\n        uint256 tokenId; // id of the token\n        uint256 amount; // amount of tokens to sell/purchase (must be 1 for ERC721, 1+ for ERC1155)\n        address strategy; // strategy for trade execution (e.g., DutchAuction, StandardSaleForFixedPrice)\n        address currency; // currency (e.g., WETH)\n        uint256 nonce; // order nonce (must be unique unless new maker order is meant to override existing one e.g., lower ask price)\n        uint256 startTime; // startTime in timestamp\n        uint256 endTime; // endTime in timestamp\n        uint256 minPercentageToAsk; // slippage protection (9000 --> 90% of the final price must return to ask)\n        bytes params; // additional parameters\n        uint8 v; // v: parameter (27 or 28)\n        bytes32 r; // r: parameter\n        bytes32 s; // s: parameter\n    }\n\n    struct TakerOrder {\n        bool isOrderAsk; // true --> ask / false --> bid\n        address taker; // msg.sender\n        uint256 price; // final price for the purchase\n        uint256 tokenId;\n        uint256 minPercentageToAsk; // // slippage protection (9000 --> 90% of the final price must return to ask)\n        bytes params; // other params (e.g., tokenId)\n    }\n}\n"
    },
    "src/exchange-wrapper/librairies/LibSeaPort.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nlibrary LibSeaPort {\n    /**\n     * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\n     *      matching, a group of six functions may be called that only requires a\n     *      subset of the usual order arguments. Note the use of a \"basicOrderType\"\n     *      enum; this represents both the usual order type as well as the \"route\"\n     *      of the basic order (a simple derivation function for the basic order\n     *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\n     */\n    struct BasicOrderParameters {\n        address considerationToken; // 0x24\n        uint256 considerationIdentifier; // 0x44\n        uint256 considerationAmount; // 0x64\n        address payable offerer; // 0x84\n        address zone; // 0xa4\n        address offerToken; // 0xc4\n        uint256 offerIdentifier; // 0xe4\n        uint256 offerAmount; // 0x104\n        BasicOrderType basicOrderType; // 0x124\n        uint256 startTime; // 0x144\n        uint256 endTime; // 0x164\n        bytes32 zoneHash; // 0x184\n        uint256 salt; // 0x1a4\n        bytes32 offererConduitKey; // 0x1c4\n        bytes32 fulfillerConduitKey; // 0x1e4\n        uint256 totalOriginalAdditionalRecipients; // 0x204\n        AdditionalRecipient[] additionalRecipients; // 0x224\n        bytes signature; // 0x244\n    }\n    /**\n     * @dev Basic orders can supply any number of additional recipients, with the\n     *      implied assumption that they are supplied from the offered ETH (or other\n     *      native token) or ERC20 token for the order.\n     */\n    struct AdditionalRecipient {\n        uint256 amount;\n        address payable recipient;\n    }\n\n    // prettier-ignore\n    enum BasicOrderType {\n        // 0: no partial fills, anyone can execute\n        ETH_TO_ERC721_FULL_OPEN,\n\n        // 1: partial fills supported, anyone can execute\n        ETH_TO_ERC721_PARTIAL_OPEN,\n\n        // 2: no partial fills, only offerer or zone can execute\n        ETH_TO_ERC721_FULL_RESTRICTED,\n\n        // 3: partial fills supported, only offerer or zone can execute\n        ETH_TO_ERC721_PARTIAL_RESTRICTED,\n\n        // 4: no partial fills, anyone can execute\n        ETH_TO_ERC1155_FULL_OPEN,\n\n        // 5: partial fills supported, anyone can execute\n        ETH_TO_ERC1155_PARTIAL_OPEN,\n\n        // 6: no partial fills, only offerer or zone can execute\n        ETH_TO_ERC1155_FULL_RESTRICTED,\n\n        // 7: partial fills supported, only offerer or zone can execute\n        ETH_TO_ERC1155_PARTIAL_RESTRICTED,\n\n        // 8: no partial fills, anyone can execute\n        ERC20_TO_ERC721_FULL_OPEN,\n\n        // 9: partial fills supported, anyone can execute\n        ERC20_TO_ERC721_PARTIAL_OPEN,\n\n        // 10: no partial fills, only offerer or zone can execute\n        ERC20_TO_ERC721_FULL_RESTRICTED,\n\n        // 11: partial fills supported, only offerer or zone can execute\n        ERC20_TO_ERC721_PARTIAL_RESTRICTED,\n\n        // 12: no partial fills, anyone can execute\n        ERC20_TO_ERC1155_FULL_OPEN,\n\n        // 13: partial fills supported, anyone can execute\n        ERC20_TO_ERC1155_PARTIAL_OPEN,\n\n        // 14: no partial fills, only offerer or zone can execute\n        ERC20_TO_ERC1155_FULL_RESTRICTED,\n\n        // 15: partial fills supported, only offerer or zone can execute\n        ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\n\n        // 16: no partial fills, anyone can execute\n        ERC721_TO_ERC20_FULL_OPEN,\n\n        // 17: partial fills supported, anyone can execute\n        ERC721_TO_ERC20_PARTIAL_OPEN,\n\n        // 18: no partial fills, only offerer or zone can execute\n        ERC721_TO_ERC20_FULL_RESTRICTED,\n\n        // 19: partial fills supported, only offerer or zone can execute\n        ERC721_TO_ERC20_PARTIAL_RESTRICTED,\n\n        // 20: no partial fills, anyone can execute\n        ERC1155_TO_ERC20_FULL_OPEN,\n\n        // 21: partial fills supported, anyone can execute\n        ERC1155_TO_ERC20_PARTIAL_OPEN,\n\n        // 22: no partial fills, only offerer or zone can execute\n        ERC1155_TO_ERC20_FULL_RESTRICTED,\n\n        // 23: partial fills supported, only offerer or zone can execute\n        ERC1155_TO_ERC20_PARTIAL_RESTRICTED\n    }\n\n    /**\n     * @dev The full set of order components, with the exception of the counter,\n     *      must be supplied when fulfilling more sophisticated orders or groups of\n     *      orders. The total number of original consideration items must also be\n     *      supplied, as the caller may specify additional consideration items.\n     */\n    struct OrderParameters {\n        address offerer; // 0x00\n        address zone; // 0x20\n        OfferItem[] offer; // 0x40\n        ConsiderationItem[] consideration; // 0x60\n        OrderType orderType; // 0x80\n        uint256 startTime; // 0xa0\n        uint256 endTime; // 0xc0\n        bytes32 zoneHash; // 0xe0\n        uint256 salt; // 0x100\n        bytes32 conduitKey; // 0x120\n        uint256 totalOriginalConsiderationItems; // 0x140\n        // offer.length                          // 0x160\n    }\n\n    /**\n     * @dev Orders require a signature in addition to the other order parameters.\n     */\n    struct Order {\n        OrderParameters parameters;\n        bytes signature;\n    }\n\n    struct AdvancedOrder {\n        OrderParameters parameters;\n        uint120 numerator;\n        uint120 denominator;\n        bytes signature;\n        bytes extraData;\n    }\n\n    struct OfferItem {\n        ItemType itemType;\n        address token;\n        uint256 identifierOrCriteria;\n        uint256 startAmount;\n        uint256 endAmount;\n    }\n\n    /**\n     * @dev A consideration item has the same five components as an offer item and\n     *      an additional sixth component designating the required recipient of the\n     *      item.\n     */\n    struct ConsiderationItem {\n        ItemType itemType;\n        address token;\n        uint256 identifierOrCriteria;\n        uint256 startAmount;\n        uint256 endAmount;\n        address payable recipient;\n    }\n\n    // prettier-ignore\n    enum OrderType {\n        // 0: no partial fills, anyone can execute\n        FULL_OPEN,\n\n        // 1: partial fills supported, anyone can execute\n        PARTIAL_OPEN,\n\n        // 2: no partial fills, only offerer or zone can execute\n        FULL_RESTRICTED,\n\n        // 3: partial fills supported, only offerer or zone can execute\n        PARTIAL_RESTRICTED\n    }\n\n    // prettier-ignore\n    enum ItemType {\n        // 0: ETH on mainnet, MATIC on polygon, etc.\n        NATIVE,\n\n        // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\n        ERC20,\n\n        // 2: ERC721 items\n        ERC721,\n\n        // 3: ERC1155 items\n        ERC1155,\n\n        // 4: ERC721 items where a number of tokenIds are supported\n        ERC721_WITH_CRITERIA,\n\n        // 5: ERC1155 items where a number of ids are supported\n        ERC1155_WITH_CRITERIA\n    }\n\n    /**\n     * @dev A fulfillment is applied to a group of orders. It decrements a series of\n     *      offer and consideration items, then generates a single execution\n     *      element. A given fulfillment can be applied to as many offer and\n     *      consideration items as desired, but must contain at least one offer and\n     *      at least one consideration that match. The fulfillment must also remain\n     *      consistent on all key parameters across all offer items (same offerer,\n     *      token, type, tokenId, and conduit preference) as well as across all\n     *      consideration items (token, type, tokenId, and recipient).\n     */\n    struct Fulfillment {\n        FulfillmentComponent[] offerComponents;\n        FulfillmentComponent[] considerationComponents;\n    }\n\n    /**\n     * @dev Each fulfillment component contains one index referencing a specific\n     *      order and another referencing a specific offer or consideration item.\n     */\n    struct FulfillmentComponent {\n        uint256 orderIndex;\n        uint256 itemIndex;\n    }\n\n    /**\n     * @dev An execution is triggered once all consideration items have been zeroed\n     *      out. It sends the item in question from the offerer to the item's\n     *      recipient, optionally sourcing approvals from either this contract\n     *      directly or from the offerer's chosen conduit if one is specified. An\n     *      execution is not provided as an argument, but rather is derived via\n     *      orders, criteria resolvers, and fulfillments (where the total number of\n     *      executions will be less than or equal to the total number of indicated\n     *      fulfillments) and returned as part of `matchOrders`.\n     */\n    struct Execution {\n        ReceivedItem item;\n        address offerer;\n        bytes32 conduitKey;\n    }\n\n    /**\n     * @dev A received item is translated from a utilized consideration item and has\n     *      the same four components as a spent item, as well as an additional fifth\n     *      component designating the required recipient of the item.\n     */\n    struct ReceivedItem {\n        ItemType itemType;\n        address token;\n        uint256 identifier;\n        uint256 amount;\n        address payable recipient;\n    }\n\n    struct CriteriaResolver {\n        uint256 orderIndex;\n        Side side;\n        uint256 index;\n        uint256 identifier;\n        bytes32[] criteriaProof;\n    }\n\n    // prettier-ignore\n    enum Side {\n        // 0: Items that can be spent\n        OFFER,\n\n        // 1: Items that must be received\n        CONSIDERATION\n    }\n}\n"
    },
    "src/exchange-wrapper/librairies/OrderStructs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nenum Side {\n    Buy,\n    Sell\n}\nenum SignatureVersion {\n    Single,\n    Bulk\n}\nenum AssetType {\n    ERC721,\n    ERC1155\n}\n\nstruct Fee {\n    uint16 rate;\n    address payable recipient;\n}\n\nstruct Order {\n    address trader;\n    Side side;\n    address matchingPolicy;\n    address collection;\n    uint256 tokenId;\n    uint256 amount;\n    address paymentToken;\n    uint256 price;\n    uint256 listingTime;\n    /* Order expiration timestamp - 0 for oracle cancellations. */\n    uint256 expirationTime;\n    Fee[] fees;\n    uint256 salt;\n    bytes extraParams;\n}\n\nstruct Input {\n    Order order;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n    bytes extraSignature;\n    SignatureVersion signatureVersion;\n    uint256 blockNumber;\n}\n\nstruct Execution {\n    Input sell;\n    Input buy;\n}\n"
    },
    "src/exchange-wrapper/tests/WrapperHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC1155Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\nimport {IWyvernExchange} from \"../interfaces/IWyvernExchange.sol\";\nimport {IExchangeV2} from \"../interfaces/IExchangeV2.sol\";\nimport {LibOrder} from \"../ExchangeWrapper.sol\";\nimport {LibDirectTransfer} from \"../ExchangeWrapper.sol\";\n\nimport {LibSeaPort} from \"../librairies/LibSeaPort.sol\";\nimport {ISeaPort} from \"../interfaces/ISeaPort.sol\";\nimport {Ix2y2} from \"../interfaces/Ix2y2.sol\";\nimport {LibLooksRare} from \"../librairies/LibLooksRare.sol\";\nimport {ILooksRare} from \"../interfaces/ILooksRare.sol\";\nimport {ILSSVMRouter} from \"../interfaces/ILSSVMRouter.sol\";\nimport {LibBlur} from \"../librairies/LibBlur.sol\";\n\ninterface IERC1155 {\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n}\n\ninterface IERC721 {\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\ninterface IMatchERC721 {\n    function matchERC721UsingCriteria(\n        address from,\n        address to,\n        IERC721 token,\n        uint256 tokenId,\n        bytes32 root,\n        bytes32[] calldata proof\n    ) external returns (bool);\n}\n\ninterface IMatchERC1155 {\n    /*This method  Merkle validator https://etherscan.io/address/0xbaf2127b49fc93cbca6269fade0f7f31df4c88a7#code\n     */\n    function matchERC1155UsingCriteria(\n        address from,\n        address to,\n        IERC1155 token,\n        uint256 tokenId,\n        uint256 amount,\n        bytes32 root,\n        bytes32[] calldata proof\n    ) external returns (bool);\n}\n\n/*Interface with error*/\ninterface IWyvernExchangeError {\n    /*method is not exist in WyvernBulkExchange contract*/\n    function atomicMatchError_(\n        address[14] memory addrs,\n        uint[18] memory uints,\n        uint8[8] memory feeMethodsSidesKindsHowToCalls,\n        bytes memory calldataBuy,\n        bytes memory calldataSell,\n        bytes memory replacementPatternBuy,\n        bytes memory replacementPatternSell,\n        bytes memory staticExtradataBuy,\n        bytes memory staticExtradataSell,\n        uint8[2] memory vs,\n        bytes32[5] memory rssMetadata\n    ) external payable;\n}\n\ncontract WrapperHelper {\n    struct WyvernOrders {\n        address[14] addrs;\n        uint[18] uints;\n        uint8[8] feeMethodsSidesKindsHowToCalls;\n        bytes calldataBuy;\n        bytes calldataSell;\n        bytes replacementPatternBuy;\n        bytes replacementPatternSell;\n        bytes staticExtradataBuy;\n        bytes staticExtradataSell;\n        uint8[2] vs;\n        bytes32[5] rssMetadata;\n    }\n\n    struct RaribleBuy {\n        LibOrder.Order orderLeft;\n        bytes signatureLeft;\n        LibOrder.Order orderRight;\n        bytes signatureRight;\n    }\n\n    struct AdditionalData {\n        bytes data;\n        uint[] additionalRoyalties;\n    }\n\n    function getDataWyvernAtomicMatch(WyvernOrders memory _openSeaBuy) external pure returns (bytes memory _data) {\n        _data = abi.encodeWithSelector(\n            IWyvernExchange.atomicMatch_.selector,\n            _openSeaBuy.addrs,\n            _openSeaBuy.uints,\n            _openSeaBuy.feeMethodsSidesKindsHowToCalls,\n            _openSeaBuy.calldataBuy,\n            _openSeaBuy.calldataSell,\n            _openSeaBuy.replacementPatternBuy,\n            _openSeaBuy.replacementPatternSell,\n            _openSeaBuy.staticExtradataBuy,\n            _openSeaBuy.staticExtradataSell,\n            _openSeaBuy.vs,\n            _openSeaBuy.rssMetadata\n        );\n    }\n\n    function getDataWyvernAtomicMatchWithError(\n        WyvernOrders memory _openSeaBuy\n    ) external pure returns (bytes memory _data) {\n        _data = abi.encodeWithSelector(\n            IWyvernExchangeError.atomicMatchError_.selector,\n            _openSeaBuy.addrs,\n            _openSeaBuy.uints,\n            _openSeaBuy.feeMethodsSidesKindsHowToCalls,\n            _openSeaBuy.calldataBuy,\n            _openSeaBuy.calldataSell,\n            _openSeaBuy.replacementPatternBuy,\n            _openSeaBuy.replacementPatternSell,\n            _openSeaBuy.staticExtradataBuy,\n            _openSeaBuy.staticExtradataSell,\n            _openSeaBuy.vs,\n            _openSeaBuy.rssMetadata\n        );\n    }\n\n    function getDataERC721UsingCriteria(\n        address from,\n        address to,\n        IERC721Upgradeable token,\n        uint256 tokenId\n    ) external pure returns (bytes memory _data) {\n        _data = abi.encodeWithSelector(IMatchERC721.matchERC721UsingCriteria.selector, from, to, token, tokenId);\n    }\n\n    function getDataERC1155UsingCriteria(\n        address from,\n        address to,\n        IERC1155Upgradeable token,\n        uint256 tokenId,\n        uint256 amount\n    ) external pure returns (bytes memory _data) {\n        _data = abi.encodeWithSelector(\n            IMatchERC1155.matchERC1155UsingCriteria.selector,\n            from,\n            to,\n            token,\n            tokenId,\n            amount\n        );\n    }\n\n    function encodeOriginFeeIntoUint(address account, uint96 value) external pure returns (uint) {\n        return (uint(value) << 160) + uint(uint160(account));\n    }\n\n    function getDataDirectPurchase(LibDirectTransfer.Purchase memory data) external pure returns (bytes memory result) {\n        result = abi.encodeWithSelector(IExchangeV2.directPurchase.selector, data);\n    }\n\n    function getDataSeaPortFulfillAdvancedOrder(\n        LibSeaPort.AdvancedOrder memory _advancedOrder,\n        LibSeaPort.CriteriaResolver[] memory _criteriaResolvers,\n        bytes32 _fulfillerConduitKey,\n        address _recipient\n    ) external pure returns (bytes memory _data) {\n        _data = abi.encodeWithSelector(\n            ISeaPort.fulfillAdvancedOrder.selector,\n            _advancedOrder,\n            _criteriaResolvers,\n            _fulfillerConduitKey,\n            _recipient\n        );\n    }\n\n    function getDataSeaPortFulfillAvailableAdvancedOrders(\n        LibSeaPort.AdvancedOrder[] memory _orders,\n        LibSeaPort.CriteriaResolver[] memory _criteriaResolvers,\n        LibSeaPort.FulfillmentComponent[][] memory _offerFulfillments,\n        LibSeaPort.FulfillmentComponent[][] memory _considerationFulfillments,\n        bytes32 _fulfillerConduitKey,\n        address _recipient,\n        uint256 _maximumFulfilled\n    ) external pure returns (bytes memory _data) {\n        _data = abi.encodeWithSelector(\n            ISeaPort.fulfillAvailableAdvancedOrders.selector,\n            _orders,\n            _criteriaResolvers,\n            _offerFulfillments,\n            _considerationFulfillments,\n            _fulfillerConduitKey,\n            _recipient,\n            _maximumFulfilled\n        );\n    }\n\n    function getDataSeaPortBasic(\n        LibSeaPort.BasicOrderParameters calldata seaPortBasic,\n        bytes4 typeNft\n    ) external pure returns (bytes memory _data) {\n        _data = abi.encode(seaPortBasic, typeNft);\n    }\n\n    function encodeData(Ix2y2.Pair721[] calldata data) external pure returns (bytes memory) {\n        return abi.encode(data);\n    }\n\n    function encodeData1155(Ix2y2.Pair1155[] calldata data) external pure returns (bytes memory) {\n        return abi.encode(data);\n    }\n\n    function hashItem(Ix2y2.Order memory order, Ix2y2.OrderItem memory item) external pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    order.salt,\n                    order.user,\n                    order.network,\n                    order.intent,\n                    order.delegateType,\n                    order.deadline,\n                    order.currency,\n                    order.dataMask,\n                    item\n                )\n            );\n    }\n\n    function encodeX2Y2Call(Ix2y2.RunInput calldata data) external pure returns (bytes memory) {\n        return abi.encode(data);\n    }\n\n    function getDataWrapperMatchAskWithTakerBidUsingETHAndWETH(\n        LibLooksRare.TakerOrder calldata _takerBid,\n        LibLooksRare.MakerOrder calldata _makerAsk,\n        bytes4 typeNft\n    ) external pure returns (bytes memory _data) {\n        _data = abi.encode(_takerBid, _makerAsk, typeNft);\n    }\n\n    function encodeFees(uint first, uint second) external pure returns (uint) {\n        return (uint(uint16(first)) << 16) + uint(uint16(second));\n    }\n\n    function encodeFeesPlusDataType(uint dataType, uint first, uint second) external pure returns (uint) {\n        return (uint(uint16(dataType)) << 32) + (uint(uint16(first)) << 16) + uint(uint16(second));\n    }\n\n    function encodeDataPlusRoyalties(AdditionalData calldata data) external pure returns (bytes memory) {\n        return abi.encode(data);\n    }\n\n    function encodeBpPlusAccount(uint bp, address account) external pure returns (uint) {\n        return (uint(bp) << 160) + uint(uint160(account));\n    }\n\n    function decodeFees(uint data) external pure returns (uint, uint) {\n        uint first = uint(uint16(data >> 16));\n        uint second = uint(uint16(data));\n        return (first, second);\n    }\n\n    function encodeSudoSwapCall(\n        ILSSVMRouter.PairSwapSpecific[] calldata swapList,\n        address payable ethRecipient,\n        address nftRecipient,\n        uint256 deadline\n    ) external pure returns (bytes memory _data) {\n        _data = abi.encodeWithSelector(\n            ILSSVMRouter.swapETHForSpecificNFTs.selector,\n            swapList,\n            ethRecipient,\n            nftRecipient,\n            deadline\n        );\n    }\n\n    function encodeDataBlur(\n        LibBlur.Input calldata buy,\n        LibBlur.Input calldata sell\n    ) external pure returns (bytes memory) {\n        return abi.encode(buy, sell);\n    }\n}\n"
    },
    "src/interfaces/IERC20TransferProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IERC20TransferProxy {\n    function erc20safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) external;\n}\n"
    },
    "src/interfaces/INftTransferProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\ninterface INftTransferProxy {\n    function erc721safeTransferFrom(IERC721Upgradeable token, address from, address to, uint256 tokenId) external;\n\n    function erc1155safeTransferFrom(\n        IERC1155Upgradeable token,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/librairies/BpLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nlibrary BpLibrary {\n    function bp(uint256 value, uint256 bpValue) internal pure returns (uint256) {\n        return (value * (bpValue)) / (10000);\n    }\n}\n"
    },
    "src/librairies/LibAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nlibrary LibAsset {\n    bytes4 public constant ETH_ASSET_CLASS = bytes4(keccak256(\"ETH\"));\n    bytes4 public constant ERC20_ASSET_CLASS = bytes4(keccak256(\"ERC20\"));\n    bytes4 public constant ERC721_ASSET_CLASS = bytes4(keccak256(\"ERC721\"));\n    bytes4 public constant ERC1155_ASSET_CLASS = bytes4(keccak256(\"ERC1155\"));\n    bytes4 public constant COLLECTION = bytes4(keccak256(\"COLLECTION\"));\n    bytes4 public constant CRYPTO_PUNKS = bytes4(keccak256(\"CRYPTO_PUNKS\"));\n\n    bytes32 public constant ASSET_TYPE_TYPEHASH = keccak256(\"AssetType(bytes4 assetClass,bytes data)\");\n\n    bytes32 public constant ASSET_TYPEHASH =\n        keccak256(\"Asset(AssetType assetType,uint256 value)AssetType(bytes4 assetClass,bytes data)\");\n\n    struct AssetType {\n        bytes4 assetClass;\n        bytes data;\n    }\n\n    struct Asset {\n        AssetType assetType;\n        uint256 value;\n    }\n\n    function hash(AssetType memory assetType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ASSET_TYPE_TYPEHASH, assetType.assetClass, keccak256(assetType.data)));\n    }\n\n    function hash(Asset memory asset) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ASSET_TYPEHASH, hash(asset.assetType), asset.value));\n    }\n}\n"
    },
    "src/librairies/LibDirectTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./LibAsset.sol\";\n\nlibrary LibDirectTransfer {\n    //LibDirectTransfers\n    /*All buy parameters need for create buyOrder and sellOrder*/\n    struct Purchase {\n        address sellOrderMaker; //\n        uint256 sellOrderNftAmount;\n        bytes4 nftAssetClass;\n        bytes nftData;\n        uint256 sellOrderPaymentAmount;\n        address paymentToken;\n        uint256 sellOrderSalt;\n        uint sellOrderStart;\n        uint sellOrderEnd;\n        bytes4 sellOrderDataType;\n        bytes sellOrderData;\n        bytes sellOrderSignature;\n        uint256 buyOrderPaymentAmount;\n        uint256 buyOrderNftAmount;\n        bytes buyOrderData;\n    }\n\n    /*All accept bid parameters need for create buyOrder and sellOrder*/\n    struct AcceptBid {\n        address bidMaker; //\n        uint256 bidNftAmount;\n        bytes4 nftAssetClass;\n        bytes nftData;\n        uint256 bidPaymentAmount;\n        address paymentToken;\n        uint256 bidSalt;\n        uint bidStart;\n        uint bidEnd;\n        bytes4 bidDataType;\n        bytes bidData;\n        bytes bidSignature;\n        uint256 sellOrderPaymentAmount;\n        uint256 sellOrderNftAmount;\n        bytes sellOrderData;\n    }\n}\n"
    },
    "src/librairies/LibMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nlibrary LibMath {\n    /// @dev Calculates partial value given a numerator and denominator rounded down.\n    ///      Reverts if rounding error is >= 0.1%\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to calculate partial of.\n    /// @return partialAmount value of target rounded down.\n    function safeGetPartialAmountFloor(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    ) internal pure returns (uint256 partialAmount) {\n        if (isRoundingErrorFloor(numerator, denominator, target)) {\n            revert(\"rounding error\");\n        }\n        partialAmount = (numerator * (target)) / (denominator);\n    }\n\n    /// @dev Checks if rounding error >= 0.1% when rounding down.\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to multiply with numerator/denominator.\n    /// @return isError Rounding error is present.\n    function isRoundingErrorFloor(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    ) internal pure returns (bool isError) {\n        if (denominator == 0) {\n            revert(\"division by zero\");\n        }\n\n        // The absolute rounding error is the difference between the rounded\n        // value and the ideal value. The relative rounding error is the\n        // absolute rounding error divided by the absolute value of the\n        // ideal value. This is undefined when the ideal value is zero.\n        //\n        // The ideal value is `numerator * target / denominator`.\n        // Let's call `numerator * target % denominator` the remainder.\n        // The absolute error is `remainder / denominator`.\n        //\n        // When the ideal value is zero, we require the absolute error to\n        // be zero. Fortunately, this is always the case. The ideal value is\n        // zero iff `numerator == 0` and/or `target == 0`. In this case the\n        // remainder and absolute error are also zero.\n        if (target == 0 || numerator == 0) {\n            return false;\n        }\n\n        // Otherwise, we want the relative rounding error to be strictly\n        // less than 0.1%.\n        // The relative error is `remainder / (numerator * target)`.\n        // We want the relative error less than 1 / 1000:\n        //        remainder / (numerator * target)  <  1 / 1000\n        // or equivalently:\n        //        1000 * remainder  <  numerator * target\n        // so we have a rounding error iff:\n        //        1000 * remainder  >=  numerator * target\n        uint256 remainder = mulmod(target, numerator, denominator);\n        isError = remainder * (1000) >= numerator * (target);\n    }\n\n    function safeGetPartialAmountCeil(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    ) internal pure returns (uint256 partialAmount) {\n        if (isRoundingErrorCeil(numerator, denominator, target)) {\n            revert(\"rounding error\");\n        }\n        partialAmount = (numerator * (target)) + (denominator - (1)) / (denominator);\n    }\n\n    /// @dev Checks if rounding error >= 0.1% when rounding up.\n    /// @param numerator Numerator.\n    /// @param denominator Denominator.\n    /// @param target Value to multiply with numerator/denominator.\n    /// @return isError Rounding error is present.\n    function isRoundingErrorCeil(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 target\n    ) internal pure returns (bool isError) {\n        if (denominator == 0) {\n            revert(\"division by zero\");\n        }\n\n        // See the comments in `isRoundingError`.\n        if (target == 0 || numerator == 0) {\n            // When either is zero, the ideal value and rounded value are zero\n            // and there is no rounding error. (Although the relative error\n            // is undefined.)\n            return false;\n        }\n        // Compute remainder as before\n        uint256 remainder = mulmod(target, numerator, denominator);\n        remainder = denominator - ((remainder) % denominator);\n        isError = remainder * (1000) >= numerator * (target);\n        return isError;\n    }\n}\n"
    },
    "src/librairies/LibOrder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./LibAsset.sol\";\nimport \"./LibMath.sol\";\nimport \"./LibOrderDataV3.sol\";\nimport \"./LibOrderDataV2.sol\";\nimport \"./LibOrderDataV1.sol\";\n\nlibrary LibOrder {\n    bytes32 public constant ORDER_TYPEHASH =\n        keccak256(\n            \"Order(address maker,Asset makeAsset,address taker,Asset takeAsset,uint256 salt,uint256 start,uint256 end,bytes4 dataType,bytes data)Asset(AssetType assetType,uint256 value)AssetType(bytes4 assetClass,bytes data)\"\n        );\n\n    bytes4 public constant DEFAULT_ORDER_TYPE = 0xffffffff;\n\n    struct Order {\n        address maker;\n        LibAsset.Asset makeAsset;\n        address taker;\n        LibAsset.Asset takeAsset;\n        uint salt;\n        uint start;\n        uint end;\n        bytes4 dataType;\n        bytes data;\n    }\n\n    function calculateRemaining(\n        Order memory order,\n        uint fill,\n        bool isMakeFill\n    ) internal pure returns (uint makeValue, uint takeValue) {\n        if (isMakeFill) {\n            makeValue = order.makeAsset.value - (fill);\n            takeValue = LibMath.safeGetPartialAmountFloor(order.takeAsset.value, order.makeAsset.value, makeValue);\n        } else {\n            takeValue = order.takeAsset.value - (fill);\n            makeValue = LibMath.safeGetPartialAmountFloor(order.makeAsset.value, order.takeAsset.value, takeValue);\n        }\n    }\n\n    function hashKey(Order memory order) internal pure returns (bytes32) {\n        if (order.dataType == LibOrderDataV1.V1 || order.dataType == DEFAULT_ORDER_TYPE) {\n            return\n                keccak256(\n                    abi.encode(\n                        order.maker,\n                        LibAsset.hash(order.makeAsset.assetType),\n                        LibAsset.hash(order.takeAsset.assetType),\n                        order.salt\n                    )\n                );\n        } else {\n            //order.data is in hash for V2, V3 and all new order\n            return\n                keccak256(\n                    abi.encode(\n                        order.maker,\n                        LibAsset.hash(order.makeAsset.assetType),\n                        LibAsset.hash(order.takeAsset.assetType),\n                        order.salt,\n                        order.data\n                    )\n                );\n        }\n    }\n\n    function hash(Order memory order) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    ORDER_TYPEHASH,\n                    order.maker,\n                    LibAsset.hash(order.makeAsset),\n                    order.taker,\n                    LibAsset.hash(order.takeAsset),\n                    order.salt,\n                    order.start,\n                    order.end,\n                    order.dataType,\n                    keccak256(order.data)\n                )\n            );\n    }\n\n    function validateOrderTime(LibOrder.Order memory order) internal view {\n        require(order.start == 0 || order.start < block.timestamp, \"Order start validation failed\");\n        require(order.end == 0 || order.end > block.timestamp, \"Order end validation failed\");\n    }\n}\n"
    },
    "src/librairies/LibOrderDataV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./LibPart.sol\";\n\nlibrary LibOrderDataV1 {\n    bytes4 public constant V1 = bytes4(keccak256(\"V1\"));\n\n    struct DataV1 {\n        LibPart.Part[] payouts;\n        LibPart.Part[] originFees;\n    }\n}\n"
    },
    "src/librairies/LibOrderDataV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./LibPart.sol\";\n\nlibrary LibOrderDataV2 {\n    bytes4 public constant V2 = bytes4(keccak256(\"V2\"));\n\n    struct DataV2 {\n        LibPart.Part[] payouts;\n        LibPart.Part[] originFees;\n        bool isMakeFill;\n    }\n}\n"
    },
    "src/librairies/LibOrderDataV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./LibPart.sol\";\n\nlibrary LibOrderDataV3 {\n    bytes4 public constant V3_SELL = bytes4(keccak256(\"V3_SELL\"));\n    bytes4 public constant V3_BUY = bytes4(keccak256(\"V3_BUY\"));\n\n    struct DataV3_SELL {\n        uint payouts;\n        uint originFeeFirst;\n        uint originFeeSecond;\n        uint maxFeesBasePoint;\n        bytes32 marketplaceMarker;\n    }\n\n    struct DataV3_BUY {\n        uint payouts;\n        uint originFeeFirst;\n        uint originFeeSecond;\n        bytes32 marketplaceMarker;\n    }\n}\n"
    },
    "src/librairies/LibPart.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nlibrary LibPart {\n    bytes32 public constant TYPE_HASH = keccak256(\"Part(address account,uint96 value)\");\n\n    struct Part {\n        address payable account;\n        uint96 value;\n    }\n\n    function hash(Part memory part) internal pure returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, part.account, part.value));\n    }\n}\n"
    },
    "src/librairies/LibTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nlibrary LibTransfer {\n    function transferEth(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(\"\");\n        require(success, \"LibTransfer BaseCurrency transfer failed\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}